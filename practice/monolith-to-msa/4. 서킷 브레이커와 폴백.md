### 4. 서킷 브레이커와 폴백 (Circuit Breaker & Fallback)

마이크로서비스 아키텍처(MSA)에서 각 서비스는 API 통신을 통해 상호작용합니다. 이 과정에서 하나의 서비스에 장애가 발생하면, 이를 의존하는 다른 서비스로 연쇄적인 장애 전파(Cascading Failure)가 일어날 수 있습니다.

서킷 브레이커는 이러한 장애 상황을 감지하여 일시적으로 요청을 차단함으로써 장애 확산을 방지하고, 폴백(Fallback)은 차단된 동안 미리 정의된 대체 응답이나 기능을 실행하여 서비스 중단을 최소화합니다.

<br />

### 서킷 브레이커 (Circuit Breaker)

전기 회로에서 과부하가 발생하면 차단기가 자동으로 내려가는 것처럼, 특정 서비스로의 요청이 계속 실패하면 자동으로 요청을 차단하여 장애 전파를 방지하는 기술입니다.

#### 서킷 브레이커 상태
- CLOSED (닫힘)
  - 정상 동작 상태
  - 서비스 요청이 정상적으로 처리됨
  - 실패율은 지속적으로 모니터링
- OPEN (열림)
  - 요청 차단 상태
  - 실패율이 설정한 임계치를 초과하여 서킷이 열림
  - 요청을 즉시 차단하고, 에러를 반환하거나 폴백 로직을 실행
  - 일정 시간이 지난 후, 새로운 요청이 들어오면 HALF_OPEN 상태로 전환
- HALF_OPEN (반쯤 열림)
  - 복구 확인 상태
  - 제한된 수의 테스트 요청만 실제 서비스로 전달
    - 설정된 횟수만큼 연속 성공하면 CLOSED 상태로 복구
    - 하나라도 실패하면 다시 OPEN 상태로 전환

<br />

### 폴백 (Fallback)

폴백은 서비스 호출이 실패했을 때를 대비하여 미리 정의된 대체 로직입니다.

서킷 브레이커가 OPEN 상태로 전환되거나 예상치 못한 오류가 발생했을 때, 에러를 그대로 반환하는 대신 안정적인 대체 응답(캐시 데이터, 기본값 등)을 제공하여 시스템의 복원력과 사용자 경험을 유지합니다.

#### Fallback 전략
- 기본값 반환
- 캐시된 데이터 활용
- 대체 서비스 호출
  - 예) 알림톡 발송 실패 시, SMS 발송
- 에러 메시지와 재시도 안내

<br />

### 서킷 브레이커 설정 및 폴백 메서드

#### 1. build.gradle

```groovy
// root build.gradle

implementation 'org.springframework.cloud:spring-cloud-starter-circuitbreaker-resilience4j' // 추가
```

#### 2. application.yml

```yaml
# order/application.yml

resilience4j:
  circuitbreaker:
    instances:
      orderService:
        register-health-indicator: true                   # [헬스 체크에 포함] /actuator/health에서 상태 확인 가능
        sliding-window-size: 5                            # [실패율 계산 범위] 최근 5번 호출로 실패율 계산
        minimum-number-of-calls: 3                        # [최소 호출 수] 최소 3번 호출해야 실패율 계산 시작
        failure-rate-threshold: 50                        # [실패율 임계값] 50% 초과시 OPEN 전환
        wait-duration-in-open-state: 10s                  # [OPEN 대기 시간] 10초 후, 요청을 받을 경우 HALF_OPEN 전환
        permitted-number-of-calls-in-half-open-state: 2   # [HALF_OPEN 테스트 횟수] 2번 연속 성공하면 CLOSED 전환
        ignoreExceptions:                                 # 해당 예외는 실패율 계산에 카운팅 되지 않음
          - "feign.FeignException$BadRequest"           # 400
          - "feign.FeignException$Unauthorized"         # 401
          - "feign.FeignException$Forbidden"            # 403
          - "feign.FeignException$NotFound"             # 404
          - "feign.FeignException$UnprocessableEntity"  # 422

management:
  endpoints:
    web:
      exposure:
        include: health,circuitbreakers,circuitbreakerevents
```

#### 3. 비즈니스 클래스

- @CircuitBreaker 어노테이션을 사용하여 서킷 브레이커를 적용할 수 있으며, name 속성 값은 application.yml의 설정과 동일해야 합니다.
- 폴백 메서드는 서비스 메서드와 동일한 시그니처를 가지며, 추가로 Throwable 객체를 매개변수로 전달받습니다.

```java
@Transactional
@CircuitBreaker(name = "orderService", fallbackMethod = "createOrderFallback") // 추가
public Order createOrder(Long userId, List<OrderItem> orderItems){
    // 주문 등록 로직..
}

public Order createOrderFallback(Long userId, List<OrderItem> orderItems, Throwable t) {
    log.error("[Fallback] {}", t.getMessage());
    // 대체 응답 로직..
}
```

<br />

### 서킷 브레이커 & 폴백 동작 시나리오

application.yml 설정 값 기반으로 시나리오를 작성합니다.

```yaml
sliding-window-size: 5                            # [실패율 계산 범위] 최근 5번 호출로 실패율 계산
minimum-number-of-calls: 3                        # [최소 호출 수] 최소 3번 호출해야 실패율 계산 시작
failure-rate-threshold: 50                        # [실패율 임계값] 50% 초과시 OPEN 전환
wait-duration-in-open-state: 10s                  # [OPEN 대기 시간] 10초 후, 요청을 받을 경우 HALF_OPEN 전환
permitted-number-of-calls-in-half-open-state: 2   # [HALF_OPEN 테스트 횟수] 2번 연속 성공하면 CLOSED 전환
```

<br />

#### 시나리오 1 : CLOSED -> OPEN

```text
- 요청 #1: ✅ 성공 (200 OK)
- 요청 #2: ❌ 실패 (500 Internal Server Error)
- 요청 #3: ❌ 실패 (503 Service Unavailable)
```
- 실패율 : 2/3 = 66.7%
- 상태 : CLOSED -> OPEN
- 동작 : 최소 호출 수(3번)를 만족하고 실패율이 50%를 초과했으므로 즉시 OPEN 상태로 전환

<br />

#### 시나리오 2 : Fallback 실행

```text
00:00 - OPEN 상태 진입
00:01 - 요청 A → 즉시 폴백 실행
00:03 - 요청 B → 즉시 폴백 실행  
00:07 - 요청 C → 즉시 폴백 실행
00:09 - 요청 D → 즉시 폴백 실행
00:10 - 10초 경과 (여전히 OPEN 상태)
00:12 - 요청 E → 🟡 HALF_OPEN 전환 + Order Service 호출 시도
```

<br />

#### 시나리오 3 : OPEN -> HALF_OPEN -> OPEN

- OPEN 상태 진입 10초 경과 후, 새로운 요청이 발생하면 HALF_OPEN 상태로 전환
- HALF_OPEN으로 전환시키는 요청 자체가 첫번째 테스트 요청이 됨

```text
[OPEN 상태 진입 10초 경과 후]
- 요청 #4: 🟡 HALF_OPEN 전환
- 요청 #4 (테스트 요청 #1): ✅ 성공 (200 OK)
- 요청 #5 (테스트 요청 #2): ❌ 실패 (500 Internal Server Error)
```
- 상태 : HALF_OPEN -> OPEN
- 동작 : 1번이라도 실패하면 OPEN 상태로 복귀

<br />

#### 시나리오 4 : OPEN -> HALF_OPEN -> CLOSED

```text
[OPEN 상태 진입 10초 경과 후]
- 요청 #6: 🟡 HALF_OPEN 전환
- 요청 #6 (테스트 요청 #1): ✅ 성공 (200 OK)
- 요청 #7 (테스트 요청 #2): ✅ 성공 (200 OK)
```
- 상태 : HALF_OPEN -> CLOSED
- 동작 : 2번 연속 성공으로 정상 상태 복구

<br />

#### 무시되는 예외 케이스

- ignoreExceptions으로 정의한 예외는 실패율 계산에 포함되지 않음
- 해당 프로젝트에서는 클라이언트 요청 오류(4xx)를 서비스 장애로 간주하지 않고, 서버 내부 오류(5xx)만 실제 장애로 판단

```text
요청 #1: ✅ 성공 (200 OK)
요청 #2: ❌ 400 Bad Request - 🚫 실패율 계산 제외 (ignoreExceptions)
요청 #3: ❌ 404 Not Found - 🚫 실패율 계산 제외 (ignoreExceptions)
요청 #4: ❌ 500 Internal Server Error - ✅ 실패율 계산 포함
요청 #5: ❌ 503 Service Unavailable - ✅ 실패율 계산 포함
```

<br />

### 관련 코드

- https://github.com/khghouse/ecommerce-monolith-to-msa

<br />

#### 참고 자료

- Claude.ai 대화 내용